KCPSM6 Assembler log file for program 'C:\Users\rkravitz\Google Drive\_PSUProjects\ece540f17\botip\firmware\bot31_pgm.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 22 Aug 2017
Assembly timestamp: 11:50:34

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 310 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 525
Memory locations available: 3571


Assembly listing

 Addr Code                   Instruction

 000                         ; -----------------------------------------------------------------
 000                         ; bot31_pgm.psm - BOTSIM 3.1 (BOT31 virtual world simulator)
 000                         ;
 000                         ; Version:   3.2
 000                         ; Author:   Roy Kravitz
 000                         ; Last Modified: 22-Aug-2017
 000                         ;
 000                         ; Revision History
 000                         ; ================
 000                         ; 04-Nov-10  RK  Created the first version from bot_pgm.psm (Bot 2.0).  Adds motor speed control
 000                         ;      and user configurability via an addition I/O port (BOT_Config)
 000                         ; 16-Nov-11  RK  Created the first version from bot30_pgm.psm (Bot 3.0).  Adds the map bit values
 000                         ;      to Sensor Register[7:6].  This was done to make it easier for a BOT application
 000                         ;      to perform special actions using the "Reserved" value (2'b11) of a BOT World map
 000                         ;      location
 000                         ; 26-Oct-12  RK  Modified for kcpsm6 and Nexys 3
 000                         ; 22-May-2015 RK  Modified for Nexys4 and Vivado,  Added dummy jumps in case the Vivado HW Manager
 000                         ;      still has problems loading the (see Picoblaze Design in Vivado document)
 000                         ; 03-Jun-2015 RK  Fixed a bug (found by Sumit Sablok) in line 846.  Was s2, should have been s1
 000                         ; 22-Aug-2017 RK  Modified to support a 75MHz simulation rate.  We did this to match the speed
 000                         ;      of the MIPSfpga CPU used for the application.  Also removes support for the
 000                         ;      LMDist and RMDist (wheel distance counters) as user-visible registers
 000                         ;
 000                         ; Description:
 000                         ; ============
 000                         ; This program implements the external world for a rojobot-based design.
 000                         ; It is responsible for moving the Rojobot simulator through the virtual
 000                         ; world it resides in.  Its other responsibility is to return the value
 000                         ; of rojobot's proximity and black line sensors.
 000                         ;
 000                         ; The program runs on a Xilinx Picoblaze which connects to Verilog
 000                         ; modules for the world map (map.v) and for whatever "external world"
 000                         ; (aka "the system") is implemented by the user.
 000                         ; As is typical of most embedded system programs, bot_pgm's main loop
 000                         ; is an infinite loop which can be represented by the following pseudo-code:
 000                         ;   while (1)  {
 000                         ;   get motor control input from "the system"
 000                         ;   simulate the rojobot  (was in rojobot.v)
 000                         ;   accumulate motor distance changes since the last time rojobot moved
 000                         ;   if (distance change >= move threshold {
 000                         ;    calculate new rojobot location coordinates
 000                         ;    update rojobot's location and orientation
 000                         ;    get new sensor values
 000                         ;    update system interface registers
 000                         ;    clear rojobot distance counters
 000                         ;    clear accumulated motor distance changes
 000                         ;   }
 000                         ;   wait for next sample interval
 000                         ;  }
 000                         ;
 000                         ; Bot 3.0 adds support for variable motor speed and user-settable wheel threshold (which also affects speed).  The
 000                         ; new options are configured through an additional I/O port  (BOT_Config) which has the following format:
 000                         ;
 000                         ;   ---------------------------------------------
 000                         ;   | x   x  th[4]  th[3] th[2] th[1] th[0] evs |
 000                         ;   ----------------------------------------------
 000                         ;  xx   *RESERVED*
 000                         ;  th[4:0]  Movement threshold.  The number of steps the left and right wheels
 000                         ;     need to make to move one position on the world map.  The bot makes
 000                         ;     a step every time the main loop is run.  So, with a threshold of 5,
 000                         ;     w/ on/off speed control enabled and both motors wheels turning
 000                         ;     forward it will take roughly 5 * 50ms = 250ms = 1/4 second to advance
 000                         ;     one position on the grid.
 000                         ;  evs   Enable Variable Speed.  If evs = 1 the application program can adjust
 000                         ;     the speed of the wheels.  If evs = 0 = on/off control, the motor speed
 000                         ;     is fixed at 1 step every time through the main loop.  When variable speed
 000                         ;     is enabled, both motors are set to the max(left motor speed, right motor speed).
 000                         ;     This is to ensure that the BOT pivots in place and ony move straight.  If the
 000                         ;     motor speeds could actually be set individually then the bot could make
 000                         ;     gradual turns or veer of the line.   I don't want to do the math.
 000                         ;
 000                         ; Bot 3.1 modifies the value of the Sensor register to include the map values for that current
 000                         ; BOT location.  The new encoding of the Sensors register is:
 000                         ;
 000                         ;   -----------------------------------------------------
 000                         ;   | Map[1]  Map[0]  x  ProxL  ProxR BlkLL BlkLC BlkLR |
 000                         ;   -----------------------------------------------------
 000                         ;  Map[1:0] World Map value for the current BOT location
 000                         ;  x   *RESERVED*
 000                         ;  ProxL  Proximity Sensor, Left
 000                         ;  ProxR  Proximity Sensor, Right
 000                         ;  BlkLL  Black Line Sensor, Left
 000                         ;  BlkLC  Black Line Sensor, Center
 000                         ;  BlkLR  Black Line Sensor, Right
 000                         ;
 000                         ; ============================================
 000                         ; === Register Names                       ===
 000                         ; === s7 - s0 registers are not dedicated  ===
 000                         ; === and keep their default names         ===
 000                         ; ============================================
 000                         NAMEREG sF, Orient                 ; rojobot's orientation
 000                         NAMEREG sE, Mvmnt                  ; rojobot's movement
 000                         NAMEREG sD, LocX                   ; rojobot location - x coordinate
 000                         NAMEREG sC, LocY                   ; rojobot location - y coordinate
 000                         NAMEREG sB, Sensor                 ; rojobot sensor values
 000                         NAMEREG sA, Botinf                 ; rojobot movement and orientation values
 000                         NAMEREG s9, LMDist                 ; left motor distance counter
 000                         NAMEREG s8, RMDist                 ; right motor distance counter
 000                         ; ======================
 000                         ; === Port Addresses ===
 000                         ; ======================
 000                         ; system interface registers
 000                         CONSTANT PRD_MOTCTL_IN, 00         ; (i) Rojobot motor control input from system
 000                         CONSTANT PWR_LOCX, 01              ; (o) X coordinate of rojobot location
 000                         CONSTANT PWR_LOCY, 02              ; (o))Y coordinate of rojobot location
 000                         CONSTANT PWR_BOTINFO, 03           ; (o) Rojobot info register
 000                         CONSTANT PWR_SENSORS, 04           ; (o) Sensor register
 000                         CONSTANT PWR_RSVD05, 05            ; () **RESERVED** (was LMDist register)
 000                         CONSTANT PWR_RSVD06, 06            ; () **RESERVED** (was RMDist register)
 000                         CONSTANT PRW_RSVD07, 07            ; () **RESERVED**
 000                         ; map logic interface ports
 000                         CONSTANT PWR_COLADR, 08            ; (o) Column address of map location
 000                         CONSTANT PWR_ROWADR, 09            ; (o) Row address of map location
 000                         CONSTANT PRD_LOCINFO, 0A           ; (i) location info from map logic
 000                         CONSTANT PRW_RSVD0B, 0B            ; () **RESERVED**
 000                         ; control signals - implemented as I/O ports w/ no data
 000                         CONSTANT PRW_LOADREGS, 0C          ; (i/o) load system interface registers
 000                         CONSTANT PRW_RSVD0D, 0D            ; () **RESERVED** (was LMDist and RMDist)
 000                         CONSTANT PRW_UPDSYSREGS, 0E        ; (i/o) system registers updated flag
 000                         CONSTANT PRW_RSVD0F, 0F            ; () **RESERVED**
 000                         CONSTANT PRD_CONFIG, 07            ; (i) Rojobot configuration register
 000                         ; =================================
 000                         ; === Scratch Pad RAM Variables ===
 000                         ; =================================
 000                         ; next orientation lookup table - this is a nibble orientated 16 entry table (8 bytes)
 000                         ; first constant is the base.  Others are the table entries
 000                         ; high nibble of entry is the next orientation if the rojobot is turning right
 000                         ; low nibble of entry is the next orientation if the rojobot is turning left
 000                         CONSTANT SP_ORTBASE, 00            ; table is based at 0x00
 000                         CONSTANT SP_ORTNO, 17              ; entry N - right is NE, left is NW
 000                         CONSTANT SP_ORTNE, 20              ; entry NE - right is E, left is N
 000                         CONSTANT SP_ORTEA, 31              ; entry E - right is SE, left is NE
 000                         CONSTANT SP_ORTSE, 42              ; entry SE - right is S, left is E
 000                         CONSTANT SP_ORTSO, 53              ; entry S - right is SW, left is SE
 000                         CONSTANT SP_ORTSW, 64              ; entry SW - right is W, left is S
 000                         CONSTANT SP_ORTWE, 75              ; entry W - right is NW, left is SW
 000                         CONSTANT SP_ORTNW, 06              ; entry NW - right is N, left is W
 000                         ; new XY lookup table - this is a byte orientated 8 entry table (8 bytes)
 000                         ; first constant is the base.  Others are the table entries
 000                         ; high nibble of entry is the increment to get new x coordinate
 000                         ; low nibble of entry is the increment to get new y coordinate
 000                         ; entry nibble values:  0=increment by 0, 1=increment by 1,
 000                         ; F - decrement by 1 (increment by -1)
 000                         CONSTANT SP_XYTBASE, 10            ; table is based at 0x10
 000                         CONSTANT SP_XYTNO, 0F              ; entry N - X is 0, Y is -1
 000                         CONSTANT SP_XYTNE, 1F              ; entry NE - X is 1, Y is -1
 000                         CONSTANT SP_XYTEA, 10              ; entry E - X is 1, Y is 0
 000                         CONSTANT SP_XYTSE, 11              ; entry SE - X is 1, Y is 1
 000                         CONSTANT SP_XYTSO, 01              ; entry S - X is 0, Y is 1
 000                         CONSTANT SP_XYTSW, F1              ; entry SW - X is -1, Y is 1
 000                         CONSTANT SP_XYTWE, F0              ; entry W - X is -1, Y is 0
 000                         CONSTANT SP_XYTNW, FF              ; entry NW - X is -1, Y is -1
 000                         ; movement lookup table - this is a nibble-oriented 16 entry table (8 bytes)
 000                         ; first constant is the base.  Others are the table entries
 000                         ; assumes dir = 1 = FWD, dir = 0 = REV
 000                         CONSTANT SP_MVTBASE, 20            ; table is based at 0x20
 000                         CONSTANT SP_MVT10, 00              ; entry 1,0 - both motors stopped
 000                         CONSTANT SP_MVT32, 00              ; entry 3,2 - both motors stopped
 000                         CONSTANT SP_MVT54, CE              ; entry 5,4 - 5 is SLT, 4 is SRT
 000                         CONSTANT SP_MVT76, CE              ; entry 7,6 - 7 is SLT, 6 is SRT
 000                         CONSTANT SP_MVT98, CC              ; entry 9,8 - 9 is SLT, 8 is SLT
 000                         CONSTANT SP_MVTBA, EE              ; entry B,A - B is SRT, A is SRT
 000                         CONSTANT SP_MVTDC, D8              ; entry D,C - D is FLT, C is REV
 000                         CONSTANT SP_MVTFE, 4F              ; entry F,E - F is FWD, E is FRT
 000                         ; Temp storage
 000                         CONSTANT TEMP1, 3F                 ; Temporary storage addresses
 000                         CONSTANT TEMP2, 3E
 000                         ; Variable motor speed support addresses
 000                         CONSTANT VS_LMTHRSH, 30            ; Left Motor Step threshold (set from CONFIG register)
 000                         CONSTANT VS_RMTHRSH, 31            ; Right Motor Step threshold (set from CONFIG register)
 000                         CONSTANT VS_MOTCMSK, 32            ; Motor control bits mask.  Set to 0x001 for on/off motor control
 000                         ; and 0x111 for variable speed control
 000                         CONSTANT VS_ENVSCTL, 33            ; Enable variable speed motor control flag (0 = on/off control, 1 = variable speed control)
 000                         ; ================================
 000                         ; === Virtual world parameters ===
 000                         ; ================================
 000                         CONSTANT WSIZE_COLS, 80            ; Virtual world has 128 columns (x coordinate)
 000                         CONSTANT WSIZE_ROWS, 80            ; Virtual world has 128 rows (y coordinate)
 000                         ; Change these two values to adjust the speed the rojobot moves in the world
 000                         ; A smaller value will speed up the rojobot and a larger value will slow down the rojobot
 000                         CONSTANT WTHR_LMOT, 05             ; accumulated left motor distance for moving rojobot
 000                         CONSTANT WTHR_RMOT, 05             ; accumulated right motor distance for moving rojobot
 000                         CONSTANT WSTRT_COL, 40             ; initial position for rojobot (col = 128 /2 = 64)
 000                         CONSTANT WSTRT_ROW, 40             ; initial position for rojobot (row = 128 /2 = 64)
 000                         CONSTANT WTYPE_GND, 00             ; location type 0 is bare "ground"
 000                         CONSTANT WTYPE_BLKL, 01            ; location type 1 is black line
 000                         CONSTANT WTYPE_OBSTR, 02           ; location type 2 is obstruction (or boundary wall)
 000                         CONSTANT WTYPE_RSVD, 03            ; location type 3 is reserved
 000                         ; ==========================
 000                         ; === Rojobot parameters ===
 000                         ; ==========================
 000                         CONSTANT DISTCTR_IVAL, 00          ; Initial value for rojobot distance counters
 000                         CONSTANT OR_N, 00                  ; Orientation is North
 000                         CONSTANT OR_NE, 01                 ; Orientation is Northeast
 000                         CONSTANT OR_E, 02                  ; Orientation is East
 000                         CONSTANT OR_SE, 03                 ; Orientation is Southeast
 000                         CONSTANT OR_S, 04                  ; Orientation is South
 000                         CONSTANT OR_SW, 05                 ; Orientation is Southwest
 000                         CONSTANT OR_W, 06                  ; Orientation is West
 000                         CONSTANT OR_NW, 07                 ; Orientation is Northwest
 000                         CONSTANT MV_STOP, 00               ; Movement is stopped
 000                         CONSTANT MV_FWD, 04                ; Movement is forward
 000                         CONSTANT MV_REV, 08                ; Movement is reverse
 000                         CONSTANT MV_SLT, 0C                ; Movement is slow left turn
 000                         CONSTANT MV_FLT, 0D                ; Movement is fast left turn
 000                         CONSTANT MV_SRT, 0E                ; Movement is slow right turn
 000                         CONSTANT MV_FRT, 0F                ; Movement is fast right turn
 000                         ; ====================
 000                         ; === Useful masks ===
 000                         ; ====================
 000                         ; NOTE:  THIS IMPLEMENTATION HAS SPEED CONTROL
 000                         ; ALL THREE SPEED BITS FOR EACH MOTOR ARE INTERPETED BUT THERE IS
 000                         ; AN ASSUMPTION THAT BOTH WHEELS ARE EITHER TURNING AT THE SAME SPEED
 000                         ; OR ARE STOPPED.  THERE IS NO VEER ALGORITHM OR VARiABLE ARCS
 000                         ; motor control register
 000                         CONSTANT MSK_RMBITS, 0F            ; right motor status is MotCtl[3:0]
 000                         CONSTANT MSK_LMBITS, F0            ; left motor status is MotCtl[7:4]
 000                         CONSTANT MSK_MOTR_STS, 0F          ; motor status is in bits[3:0]
 000                         ; DISABLE SPEED CONTROL BY ONLY LOOKING AT LSB - DEFAULT
 000                         CONSTANT MSK_MOTSPD, 01            ; motor speed bits - no speed control
 000                         ; ENABLE SPEED CONTROL BY LOOKING AT ALL 3 SPEED BITS INSTEAD OF JUST LSB
 000                         CONSTANT MSK_VMOTSPD, 07           ; motor speed bits - w/ variable speed control
 000                         ; ==============================
 000                         ; === Other useful constants ===
 000                         ; ==============================
 000                         ;Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                         ;clock applied to KCPSM6. Every instruction executes in 2 clock cycles making the
 000                         ;calculation highly predictable. The '6' in the following equation even allows for
 000                         ;'CALL delay_1us' instruction in the initiating code.
 000                         ;
 000                         ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                         ;
 000                         ;For our 50MHz clock the constant value is (75 - 6)/4 = 69/4 = 17  (11 Hex).
 000                         ;For clock rates below 10MHz the value of 1 must be used and the operation will
 000                         ;become lower than intended.
 000                         ;
 000                         CONSTANT DELAYVAL_1uS, 17'd        ; 1us delay count
 000                         ; ===============
 000                         ; === main()  ===
 000                         ; ===============
 000                         ADDRESS 000
 000                  start: 
 000  22004                  JUMP 004[main]                     ; workaround to avoid location 3 corruption
 001  22004                  JUMP 004[main]                     ; by Vivado Hardware Manager.  Bug was flagged by
 002  22004                  JUMP 004[main]                     ; Ken Chapman and is known to be in 2014.2
 003  22004                  JUMP 004[main]                     ; Address 003 can be corrupted by Vivado HW manager
 004                         ;
 004                         ;    JUMP test_wrldIF     ; test the world I/F
 004  20047            main: CALL 047[init_mvlkuptbl]           ; initialize movement lookup table
 005  20065                  CALL 065[init_orlkuptbl]           ; initialize orientation lookup table
 006  200B1                  CALL 0B1[init_xylkuptbl]           ; initialize xy increment lookup table
 007  01F02                  LOAD sF[Orient], 02[OR_E]          ; Position the BOT Stopped and facing East
 008  01E00                  LOAD sE[Mvmnt], 00[MV_STOP]
 009  01D40                  LOAD sD[LocX], 40[WSTRT_COL]       ; in the middle of the world
 00A  01C40                  LOAD sC[LocY], 40[WSTRT_ROW]       ;
 00B  20028                  CALL 028[upd_sysregs]              ; Display initial values of system registers
 00C  201AC                  CALL 1AC[init_rojobot]             ; then initialize the Rojobot
 00D                         ; and enter main emulation loop
 00D                         ; ===========================
 00D                         ; === Main Emulation Loop ===
 00D                         ; ===========================
 00D  09007         emul_lp: INPUT s0, 07[PRD_CONFIG]           ; get BOT configuration from system and save in S0
 00E  20199                  CALL 199[adjthresh]                ; adjust wheel thresholds and masks based on configuration
 00F  09000                  INPUT s0, 00[PRD_MOTCTL_IN]        ; get motor controls from "system" and save in s0
 010  201B2                  CALL 1B2[rojobot]                  ; and simulate rojobot
 011                         ; motor status bits are returned in s0
 011  20060                  CALL 060[calc_movement]            ; next calculate the movement-it may have changed
 012  00E00                  LOAD sE[Mvmnt], s0                 ; movement is returned in s0 - save it
 013  20028                  CALL 028[upd_sysregs]              ; next update the system registers
 014  0B030                  FETCH s0, 30[VS_LMTHRSH]           ; Fetch left motor threshold from scratchpad RAM
 015  1C900                  COMPARE s9[LMDist], s0             ; has left motor moved more than the threshold?
 016  3E01B                  JUMP NC, 01B[emul_lp01]            ; yes if CF = 0 need to update the world
 017  1D031                  COMPARE s0, 31[VS_RMTHRSH]         ; Fetch right motor threshold from scratchpad RAM
 018  1C800                  COMPARE s8[RMDist], s0             ; has right motor moved more than the threshold?
 019  3E01B                  JUMP NC, 01B[emul_lp01]            ; yes if CF = 0 need to update the world
 01A  22026                  JUMP 026[naptime]                  ; no world update needed - it's nap time
 01B                         ;  update the world starts here - global registers and SP RAM locations are affected
 01B                         ;  see description of individual functions for what registers and memory get changed
 01B  001F0       emul_lp01: LOAD s1, sF[Orient]                ; calculate new orientation based on movement
 01C  002E0                  LOAD s2, sE[Mvmnt]                 ; s1 gets current orientation, s2 gets
 01D  20083                  CALL 083[calc_orient]              ; current movement. new orientation is
 01E  00F00                  LOAD sF[Orient], s0                ; returned in s0.  Save new orientation
 01F  001F0                  LOAD s1, sF[Orient]                ; get the new location coordinates
 020  002E0                  LOAD s2, sE[Mvmnt]                 ; s1 gets current orientation, s2 gets movement
 021  200D3                  CALL 0D3[get_newxy]                ; on return s0 has x coord and s1 has y coord
 022  00D00                  LOAD sD[LocX], s0                  ; and save the new location
 023  00C10                  LOAD sC[LocY], s1
 024  01900                  LOAD s9[LMDist], 00[DISTCTR_IVAL]  ; then clear the left and right
 025  01800                  LOAD s8[RMDist], 00[DISTCTR_IVAL]  ; motor distance counters
 026                         ; nap time - emulation sleeps for 50ms and then starts again
 026  201E3         naptime: CALL 1E3[delay_50ms]               ; software 50ms delay timing loop
 027  2200D                  JUMP 00D[emul_lp]                  ; and start again
 028                         ;**************************************************************************************
 028                         ; Support functions
 028                         ;**************************************************************************************
 028                         ;*******
 028                         ; Functions to update system registers
 028                         ;*******
 028                         ; =====================================================================
 028                         ; === upd_sysregs() - updates the system registers                  ===
 028                         ; === Registers affected: s0, s1, s2,s3, s4, s5, s6, s7             ===
 028                         ; === Also affects global registers Sensor, Botinf                  ===
 028                         ; === Uses the rojobot location, orientation, and movement to       ===
 028                         ; === read the map (for sensors) and build BotInfo register         ===
 028                         ; === Toggles the "system registers updated" flag                   ===
 028                         ; =====================================================================
 028  001D0     upd_sysregs: LOAD s1, sD[LocX]                  ; s1 and s2 get rojobot location
 029  002C0                  LOAD s2, sC[LocY]                  ; s0 will get new sensor reg value
 02A  20105                  CALL 105[get_sensors]              ; get the new sensor register
 02B  00B00                  LOAD sB[Sensor], s0                ; and save
 02C  20190                  CALL 190[get_botinfo]              ; get the new rojobot info register
 02D  00A00                  LOAD sA[Botinf], s0                ; and save
 02E  2DD01                  OUTPUT sD[LocX], 01[PWR_LOCX]      ; update the system interface registers
 02F  2DC02                  OUTPUT sC[LocY], 02[PWR_LOCY]      ; these are holding registers in the
 030  2DB04                  OUTPUT sB[Sensor], 04[PWR_SENSORS] ; world_if.v hardware.  The system-visible
 031  2DA03                  OUTPUT sA[Botinf], 03[PWR_BOTINFO] ; registers are updated w/ the
 032  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ; LOAD REG signal.  First write toggles to 1
 033  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ; Second write toggles to 0
 034  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; toggle the "system registers updated" flag
 035  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; First write togles to 1, second write to 0
 036  25000                  RETURN 
 037                         ;*******
 037                         ; Functions to look up values
 037                         ;*******
 037                         ; =====================================================================
 037                         ; === lkup_nib() - looks up an entry in a nibble-based lookup table ===
 037                         ; === Registers affected: s0, s1, s2                                ===
 037                         ; === s1 contains the value to lookup,  s2 contains the base        ===
 037                         ; === address of the table.  entry is returned in low nibble of s0  ===
 037                         ; =====================================================================
 037  00010        lkup_nib: LOAD s0, s1                        ; save value to lookup in s0
 038  1400E                  SR0 s0                             ; 2 entries/byte to divide by 2
 039  10200                  ADD s2, s0                         ; add to table base to get offset
 03A  0A020                  FETCH s0, (s2)                     ; and fetch the entry
 03B  1410E                  SR0 s1                             ; test if value is even or odd
 03C  3E042                  JUMP NC, 042[lkup_nib01]           ; if CY = 1 it's odd entry in table
 03D  1400E                  SR0 s0                             ; so shift high nibble to low nibble
 03E  1400E                  SR0 s0                             ;
 03F  1400E                  SR0 s0                             ;
 040  1400E                  SR0 s0                             ;
 041  25000                  RETURN                             ; and return
 042  0300F      lkup_nib01: AND s0, 0F                         ; entry in low nibble so mask
 043  25000                  RETURN                             ; out upper nibble and return
 044                         ; =====================================================================
 044                         ; === lkup_byte() - looks up an entry in a byte-based lookup table  ===
 044                         ; === Registers affected: s0, s1, s2                                ===
 044                         ; === s1 contains the value to lookup,  s2 contains the base        ===
 044                         ; === address of the table.  entry is returned in s0                ===
 044                         ; =====================================================================
 044  10210       lkup_byte: ADD s2, s1                         ; add to table base to get offset
 045  0A020                  FETCH s0, (s2)                     ; and fetch the entry
 046  25000                  RETURN 
 047                         ;*******
 047                         ; Functions to calculate movement
 047                         ;*******
 047                         ; =====================================================================
 047                         ; === init_mvlkuptbl() - initialize movement lookup table in SP RAM ===
 047                         ; === Registers affected: s0, s1                                    ===
 047                         ; =====================================================================
 047  01020  init_mvlkuptbl: LOAD s0, 20[SP_MVTBASE]            ; s0 gets base of movement lookup table
 048  01100                  LOAD s1, 00[SP_MVT10]              ; s1 gets values for entries 1 and 0
 049  2E100                  STORE s1, (s0)                     ; store the entry in the table
 04A  11001                  ADD s0, 01                         ; increment the table index
 04B  01100                  LOAD s1, 00[SP_MVT32]              ; s1 gets values for entries 3 and 2
 04C  2E100                  STORE s1, (s0)                     ; store the entry in the table
 04D  11001                  ADD s0, 01                         ; increment the table index
 04E  011CE                  LOAD s1, CE[SP_MVT54]              ; s1 gets values for entries 5 and 4
 04F  2E100                  STORE s1, (s0)                     ; store the entry in the table
 050  11001                  ADD s0, 01                         ; increment the table index
 051  011CE                  LOAD s1, CE[SP_MVT76]              ; s1 gets values for entries 7 and 6
 052  2E100                  STORE s1, (s0)                     ; store the entry in the table
 053  11001                  ADD s0, 01                         ; increment the table index
 054  011CC                  LOAD s1, CC[SP_MVT98]              ; s1 gets values for entries 9 and 8
 055  2E100                  STORE s1, (s0)                     ; store the entry in the table
 056  11001                  ADD s0, 01                         ; increment the table index
 057  011EE                  LOAD s1, EE[SP_MVTBA]              ; s1 gets values for entries 11 and 10
 058  2E100                  STORE s1, (s0)                     ; store the entry in the table
 059  11001                  ADD s0, 01                         ; increment the table index
 05A  011D8                  LOAD s1, D8[SP_MVTDC]              ; s1 gets values for entries 13 and 12
 05B  2E100                  STORE s1, (s0)                     ; store the entry in the table
 05C  11001                  ADD s0, 01                         ; increment the table index
 05D  0114F                  LOAD s1, 4F[SP_MVTFE]              ; s1 gets values for entries 15 and 14
 05E  2E100                  STORE s1, (s0)                     ; store the entry in the table
 05F  25000                  RETURN                             ; done...at last
 060                         ; ===========================================================================
 060                         ; === calc_movement() - uses motor status register bits[3:0] to calculate ===
 060                         ; === the rojobot's movement (fwd, rev, stopped, etc.)                    ===
 060                         ; === Registers affected: s0, s1, s2                                      ===
 060                         ; === s0 contains the contents of motor status reg, result returned in s0 ===
 060                         ; === The calculation is done by looking up the movement in the nibble    ===
 060                         ; === based movement lookup table                                         ===
 060                         ; ===========================================================================
 060  00100   calc_movement: LOAD s1, s0                        ; move motor status to s1
 061  0310F                  AND s1, 0F[MSK_MOTR_STS]           ; isolate the motor on and direction bits
 062  01220                  LOAD s2, 20[SP_MVTBASE]            ; s2 gets base of movement lookup table
 063  20037                  CALL 037[lkup_nib]                 ; look up the movement
 064  25000                  RETURN                             ; results are returned in s0
 065                         ;*******
 065                         ; Functions to calculate orientation
 065                         ;*******
 065                         ; ========================================================================
 065                         ; === init_orlkuptbl() - initialize orientation lookup table in SP RAM ===
 065                         ; === Registers affected: s0, s1                                       ===
 065                         ; ========================================================================
 065  01000  init_orlkuptbl: LOAD s0, 00[SP_ORTBASE]            ; s0 gets base of orientation lookup table
 066  01117                  LOAD s1, 17[SP_ORTNO]              ; s1 gets values for entries for North
 067  2E100                  STORE s1, (s0)                     ; store the entry in the table
 068  11001                  ADD s0, 01                         ; increment the table index
 069  01120                  LOAD s1, 20[SP_ORTNE]              ; s1 gets values for entries Northeast
 06A  2E100                  STORE s1, (s0)                     ; store the entry in the table
 06B  11001                  ADD s0, 01                         ; increment the table index
 06C  01131                  LOAD s1, 31[SP_ORTEA]              ; s1 gets values for entries East
 06D  2E100                  STORE s1, (s0)                     ; store the entry in the table
 06E  11001                  ADD s0, 01                         ; increment the table index
 06F  01142                  LOAD s1, 42[SP_ORTSE]              ; s1 gets values for entries Southeast
 070  2E100                  STORE s1, (s0)                     ; store the entry in the table
 071  11001                  ADD s0, 01                         ; increment the table index
 072  01153                  LOAD s1, 53[SP_ORTSO]              ; s1 gets values for entries South
 073  2E100                  STORE s1, (s0)                     ; store the entry in the table
 074  11001                  ADD s0, 01                         ; increment the table index
 075  01164                  LOAD s1, 64[SP_ORTSW]              ; s1 gets values for entries Southwest
 076  2E100                  STORE s1, (s0)                     ; store the entry in the table
 077  11001                  ADD s0, 01                         ; increment the table index
 078  01175                  LOAD s1, 75[SP_ORTWE]              ; s1 gets values for entries West
 079  2E100                  STORE s1, (s0)                     ; store the entry in the table
 07A  11001                  ADD s0, 01                         ; increment the table index
 07B  01106                  LOAD s1, 06[SP_ORTNW]              ; s1 gets values for entries Northwest
 07C  2E100                  STORE s1, (s0)                     ; store the entry in the table
 07D  25000                  RETURN                             ; done...at last
 07E                         ; =========================================================================
 07E                         ; === next_orient() - selects next orientation                          ===
 07E                         ; === Registers affected: s0, s1, s2, s3                                ===
 07E                         ; === s1 contains the current orientation, s2 contains the base address ===
 07E                         ; === of the table, s3 contains the direction.                          ===
 07E                         ; === s3=1 says turning right, s3=0 says turning left, new value is     ===
 07E                         ; === returned in s0.                                                   ===
 07E                         ; === The calculation is done by looking up the orientation in the      ===
 07E                         ; === nibble-based orientation lookup table                             ===
 07E                         ; =========================================================================
 07E  14106     next_orient: SL0 s1                             ; adjust for 2 entries per orientation
 07F  10130                  ADD s1, s3                         ; adjust for left/right turn
 080  01200                  LOAD s2, 00[SP_ORTBASE]            ; s2 gets base of orientation lookup table
 081  20037                  CALL 037[lkup_nib]                 ; look up the orientation
 082  25000                  RETURN                             ; results are returned in s0
 083                         ; ==========================================================================
 083                         ; === calc_orient() - calculates new orientation                         ===
 083                         ; === Registers affected: s0, s1, s2, s3, s4, s5                         ===
 083                         ; === s1 contains the current orientation, s2 contains the current       ===
 083                         ; === movement.  On return s0 contains new orientation.                  ===
 083                         ; === s4 and s5 are used as temporary registers                          ===
 083                         ; === The calculation is done by a switch statment based on the movement ===
 083                         ; ==========================================================================
 083  00410     calc_orient: LOAD s4, s1                        ; save the current orientation
 084  00520                  LOAD s5, s2                        ; save the current movement
 085                         ; switch (movement) {
 085  1D500     co_caseSTOP: COMPARE s5, 00[MV_STOP]            ; case(MV_STOP):
 086  36089                  JUMP NZ, 089[co_caseFWD]           ;
 087  00040                  LOAD s0, s4                        ;  s0 = current orientation
 088  220B0                  JUMP 0B0[co_endcase]               ;
 089                         ;
 089  1D504      co_caseFWD: COMPARE s5, 04[MV_FWD]             ; case (MV_FWD):
 08A  3608D                  JUMP NZ, 08D[co_caseREV]           ;
 08B  00040                  LOAD s0, s4                        ;  s0 = current orientation
 08C  220B0                  JUMP 0B0[co_endcase]               ;
 08D                         ;
 08D  1D508      co_caseREV: COMPARE s5, 08[MV_REV]             ; case (MV_REV):
 08E  36091                  JUMP NZ, 091[co_caseSLT]           ;
 08F  00040                  LOAD s0, s4                        ;  s0 = current orientation
 090  220B0                  JUMP 0B0[co_endcase]               ;
 091                         ;
 091  1D50C      co_caseSLT: COMPARE s5, 0C[MV_SLT]             ; case (MV_SLT):
 092  36097                  JUMP NZ, 097[co_caseFLT]           ;
 093  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 094  01300                  LOAD s3, 00                        ;    current orientation
 095  2007E                  CALL 07E[next_orient]              ;     turning left)
 096  220B0                  JUMP 0B0[co_endcase]               ;
 097                         ;
 097  1D50D      co_caseFLT: COMPARE s5, 0D[MV_FLT]             ; case (MV_FLT):
 098  360A0                  JUMP NZ, 0A0[co_caseSRT]           ;
 099  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 09A  01300                  LOAD s3, 00                        ;    current orientation
 09B  2007E                  CALL 07E[next_orient]              ;     turning left)
 09C  00100                  LOAD s1, s0                        ;   s0 = next_orient(
 09D  01300                  LOAD s3, 00                        ;    current orientation
 09E  2007E                  CALL 07E[next_orient]              ;     turning left)
 09F  220B0                  JUMP 0B0[co_endcase]               ;
 0A0                         ;
 0A0  1D50E      co_caseSRT: COMPARE s5, 0E[MV_SRT]             ; case (MV_SRT):
 0A1  360A6                  JUMP NZ, 0A6[co_caseFRT]           ;
 0A2  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 0A3  01301                  LOAD s3, 01                        ;    current orientation
 0A4  2007E                  CALL 07E[next_orient]              ;     turning right)
 0A5  220B0                  JUMP 0B0[co_endcase]               ;
 0A6                         ;
 0A6  1D50F      co_caseFRT: COMPARE s5, 0F[MV_FRT]             ; case (MV_FRT):
 0A7  360AF                  JUMP NZ, 0AF[co_caseDFLT]          ;
 0A8  00140                  LOAD s1, s4                        ;   s0 = next_orient(
 0A9  01301                  LOAD s3, 01                        ;    current orientation
 0AA  2007E                  CALL 07E[next_orient]              ;     turning right)
 0AB  00100                  LOAD s1, s0                        ;   s0 = next_orient(
 0AC  01301                  LOAD s3, 01                        ;    current orientation
 0AD  2007E                  CALL 07E[next_orient]              ;     turning right)
 0AE  220B0                  JUMP 0B0[co_endcase]               ;
 0AF                         ;
 0AF  00040     co_caseDFLT: LOAD s0, s4                        ; default:
 0B0                         ;   s0 = current_orientation
 0B0  25000      co_endcase: RETURN                             ; return new orientation in s0
 0B1                         ;*******
 0B1                         ; Functions to calculate new location coordinates
 0B1                         ;*******
 0B1                         ; =====================================================================
 0B1                         ; === init_xylkuptbl() - initialize xy incr  lookup table in SP RAM ===
 0B1                         ; === Registers affected: s0, s1                                    ===
 0B1                         ; =====================================================================
 0B1  01010  init_xylkuptbl: LOAD s0, 10[SP_XYTBASE]            ; s0 gets base of xy increment lookup table
 0B2  0110F                  LOAD s1, 0F[SP_XYTNO]              ; s1 gets values for entries for North
 0B3  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0B4  11001                  ADD s0, 01                         ; increment the table index
 0B5  0111F                  LOAD s1, 1F[SP_XYTNE]              ; s1 gets values for entries Northeast
 0B6  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0B7  11001                  ADD s0, 01                         ; increment the table index
 0B8  01110                  LOAD s1, 10[SP_XYTEA]              ; s1 gets values for entries East
 0B9  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0BA  11001                  ADD s0, 01                         ; increment the table index
 0BB  01111                  LOAD s1, 11[SP_XYTSE]              ; s1 gets values for entries Southeast
 0BC  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0BD  11001                  ADD s0, 01                         ; increment the table index
 0BE  01101                  LOAD s1, 01[SP_XYTSO]              ; s1 gets values for entries South
 0BF  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0C0  11001                  ADD s0, 01                         ; increment the table index
 0C1  011F1                  LOAD s1, F1[SP_XYTSW]              ; s1 gets values for entries Southwest
 0C2  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0C3  11001                  ADD s0, 01                         ; increment the table index
 0C4  011F0                  LOAD s1, F0[SP_XYTWE]              ; s1 gets values for entries West
 0C5  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0C6  11001                  ADD s0, 01                         ; increment the table index
 0C7  011FF                  LOAD s1, FF[SP_XYTNW]              ; s1 gets values for entries Northwest
 0C8  2E100                  STORE s1, (s0)                     ; store the entry in the table
 0C9  25000                  RETURN                             ; done...at last
 0CA                         ; =========================================================================
 0CA                         ; === next_xy() - returns x and y increment values for next location    ===
 0CA                         ; === Registers affected: s0, s1, s2, s3                                ===
 0CA                         ; === s1 contains the current orientation, s2 contains the base address ===
 0CA                         ; === of the table.  The x increment is returned in s0 and the y        ===
 0CA                         ; === increment is returned in s1                                       ===
 0CA                         ; === The calculation is done by looking up the increments in the       ===
 0CA                         ; === byte-based xy lookup table.  The x increment is in the upper      ===
 0CA                         ; === nibble and the y increment is in the lower nibble of the entries  ===
 0CA                         ; =========================================================================
 0CA  01210         next_xy: LOAD s2, 10[SP_XYTBASE]            ; s2 gets base of xy increment lookup table
 0CB  20044                  CALL 044[lkup_byte]                ; look up the orientation
 0CC  00100                  LOAD s1, s0                        ; s1 gets copy of results
 0CD  0310F                  AND s1, 0F                         ; low nibble is y increment
 0CE  1400E                  SR0 s0                             ; shift s0 x 4 to move
 0CF  1400E                  SR0 s0                             ; high nibble down
 0D0  1400E                  SR0 s0                             ;
 0D1  1400E                  SR0 s0                             ;
 0D2  25000                  RETURN                             ; return
 0D3                         ; =========================================================================
 0D3                         ; === get_newxy() - returns x and y coordinates for new Rojobot location===
 0D3                         ; === Registers affected: s0, s1, s2, s3, s4, s5, s6, s7                ===
 0D3                         ; === s1 contains the crnt orientation, s2 contains the crnt movement   ===
 0D3                         ; === The new x location is returned in s0 and the new y location       ===
 0D3                         ; === is returned in s1.                                                ===
 0D3                         ; === The rojobot only changes location when it is moving forward or    ===
 0D3                         ; === backward and if the location it is moving into is not obstructed. ===
 0D3                         ; ===                                                                   ===
 0D3                         ; === The function will not move the Rojobot onto an obstructed         ===
 0D3                         ; === location.                                                         ===
 0D3                         ; =========================================================================
 0D3  00420       get_newxy: LOAD s4, s2                        ; save crnt movement - s2 will change
 0D4  00510                  LOAD s5, s1                        ; save crnt orientation - s1 will change
 0D5  006D0                  LOAD s6, sD[LocX]                  ; save current x coordinate in s6
 0D6  007C0                  LOAD s7, sC[LocY]                  ; save current y location in s7
 0D7  200CA                  CALL 0CA[next_xy]                  ; s1 contains the orientation
 0D8                         ; on return s0 has x incr, s1 has y incr
 0D8                         ; incr = 0 or 1 or if F incr is -1
 0D8                         ;
 0D8  1D404                  COMPARE s4, 04[MV_FWD]             ;  if (Mvmnt == FWD)  {
 0D9  360E5                  JUMP NZ, 0E5[gnxy_00]              ; -- Z != 0 says not FWD, check if REV
 0DA  1D00F                  COMPARE s0, 0F                     ;  if (xcoord == 0x0F)
 0DB  360DE                  JUMP NZ, 0DE[gnxy_01]              ; -- Z != says xcoord != 0F
 0DC  19601                  SUB s6, 01                         ;   newx = LocX - 1
 0DD  220DF                  JUMP 0DF[gnxy_02]                  ;  else
 0DE  10600         gnxy_01: ADD s6, s0                         ;   newx = LocX + incr (either 0 or 1)
 0DF  1D10F         gnxy_02: COMPARE s1, 0F                     ;  if (ycoord = 0x0F)
 0E0  360E3                  JUMP NZ, 0E3[gnxy_03]              ;   newy = LocY -1
 0E1  19701                  SUB s7, 01                         ;
 0E2  220F5                  JUMP 0F5[gnxy_chk0B]               ;  else
 0E3  10710         gnxy_03: ADD s7, s1                         ;   newy = LocY + incr (either 0 or 1)
 0E4  220F5                  JUMP 0F5[gnxy_chk0B]               ; }  // end Mvmnt == FWD
 0E5  1D408         gnxy_00: COMPARE s4, 08[MV_REV]             ; else if (Mvmnt == REV)  {
 0E6  360F2                  JUMP NZ, 0F2[gnxy_nofwdrev]        ; -- Z != says not REV so position won't change
 0E7  1D00F                  COMPARE s0, 0F                     ;  if (xcoord == 0x0F)
 0E8  360EB                  JUMP NZ, 0EB[gnxy_04]              ;
 0E9  11601                  ADD s6, 01                         ;   newx = LocX + 1
 0EA  220EC                  JUMP 0EC[gnxy_05]                  ;  else
 0EB  18600         gnxy_04: SUB s6, s0                         ;   newx = LocX - incr (either 0 or 1)
 0EC  1D10F         gnxy_05: COMPARE s1, 0F                     ;  if (ycoord == 0x0F)
 0ED  360F0                  JUMP NZ, 0F0[gnxy_06]              ;
 0EE  11701                  ADD s7, 01                         ;   newy = LocY + 1
 0EF  220F5                  JUMP 0F5[gnxy_chk0B]               ;  else
 0F0  18710         gnxy_06: SUB s7, s1                         ;   newy = LocY - incr (either 0 or 1)
 0F1  220F5                  JUMP 0F5[gnxy_chk0B]               ; } // end Mvmnt == REV
 0F2  00060   gnxy_nofwdrev: LOAD s0, s6                        ;  Not forward or reverse so return current X and Y
 0F3  00170                  LOAD s1, s7                        ;
 0F4  25000                  RETURN                             ;
 0F5                         ;
 0F5  00160      gnxy_chk0B: LOAD s1, s6                        ; Check if new location is obstructed
 0F6  00270                  LOAD s2, s7                        ; s1 = newx,  s2 = new y
 0F7  20100                  CALL 100[get_mapvalue]             ; s0 = value of Map location on return
 0F8  1D002                  COMPARE s0, 02[WTYPE_OBSTR]        ; if (Map(x,y) == OBSTR)  {
 0F9  360FD                  JUMP NZ, 0FD[gnxy_07]              ; -- Z != 1 says location is not obstructed
 0FA  000D0                  LOAD s0, sD[LocX]                  ;    s0 = old location (x)
 0FB  001C0                  LOAD s1, sC[LocY]                  ;  s1 = old location (y)
 0FC  25000                  RETURN                             ;  return
 0FD                         ; }
 0FD  00060         gnxy_07: LOAD s0, s6                        ; else  {
 0FE  00170                  LOAD s1, s7                        ;  s0 = newx; s1 = newy;
 0FF  25000                  RETURN                             ;  return
 100                         ;*******
 100                         ; Functions to manipulate world map
 100                         ;*******
 100                         ; =============================================================================
 100                         ; === get_mapvalue() - returns the value of map location                    ===
 100                         ; === Registers affected: s0, s1, s2                                        ===
 100                         ; === s1 contains the x (col) coordinate and s2 contains the y coordinate   ===
 100                         ; === of the location to access.  the map value for that location is        ===
 100                         ; === returns in s0.                                                        ===
 100                         ; =============================================================================
 100  2D108    get_mapvalue: OUTPUT s1, 08[PWR_COLADR]          ; send column address to map logic
 101  2D209                  OUTPUT s2, 09[PWR_ROWADR]          ; send row address to map logic
 102  00000                  LOAD s0, s0                        ; NOP to give memory plenty of time for read
 103  0900A                  INPUT s0, 0A[PRD_LOCINFO]          ; and get results from map memory
 104  25000                  RETURN                             ; all done
 105                         ;*******
 105                         ; Functions to generate the external registers
 105                         ;*******
 105                         ; =============================================================================
 105                         ; === get_sensors() - returns the value of the sensor register              ===
 105                         ; === Registers affected: s0, s1, s2, s3, s4, s5, s6, s7                    ===
 105                         ; === s1 contains the x (col) coordinate, s2 contains the y coordinate      ===
 105                         ; === of the location to access.  The global register Orient contains the   ===
 105                         ; === BOT's orientation. The new sensor register value is returned in s0.   ===
 105                         ; =============================================================================
 105                         ; switch(Orient)  {
 105  001D0     get_sensors: LOAD s1, sD[LocX]                  ; get_mapvalue(LocX, LocY)
 106  002C0                  LOAD s2, sC[LocY]                  ;
 107  20100                  CALL 100[get_mapvalue]             ; s0 = map(LocX, LocY)
 108  00700                  LOAD s7, s0                        ; s7 gets map(LocX, Loc)
 109  1DF00      gs_caseORN: COMPARE sF[Orient], 00[OR_N]       ; case(OR_N):
 10A  36117                  JUMP NZ, 117[gs_caseORNE]          ;
 10B  19101                  SUB s1, 01                         ;   s4 = gets map(LocX-1, LocY-1)
 10C  19201                  SUB s2, 01                         ;
 10D  20100                  CALL 100[get_mapvalue]             ;
 10E  00400                  LOAD s4, s0                        ;
 10F  11101                  ADD s1, 01                         ;   s5 = gets map(LocX, LocY-1)
 110  20100                  CALL 100[get_mapvalue]             ;
 111  00500                  LOAD s5, s0                        ;
 112  11101                  ADD s1, 01                         ;   s6 = gets map(LocX+1, LocY-1)
 113  20100                  CALL 100[get_mapvalue]             ;
 114  00600                  LOAD s6, s0                        ;
 115  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 116  25000                  RETURN                             ;  continue;
 117                         ;
 117  1DF01     gs_caseORNE: COMPARE sF[Orient], 01[OR_NE]      ; case (OR_NE):
 118  36125                  JUMP NZ, 125[gs_caseORE]           ;
 119  11101                  ADD s1, 01                         ;   s4 = gets map(LocX+1, LocY-2)
 11A  19202                  SUB s2, 02                         ;
 11B  20100                  CALL 100[get_mapvalue]             ;
 11C  00400                  LOAD s4, s0                        ;
 11D  11201                  ADD s2, 01                         ;   s5 = gets map(LocX+1, LocY-1)
 11E  20100                  CALL 100[get_mapvalue]             ;
 11F  00500                  LOAD s5, s0                        ;
 120  11101                  ADD s1, 01                         ;   s6 = gets map(LocX+2, LocY-1)
 121  20100                  CALL 100[get_mapvalue]             ;
 122  00600                  LOAD s6, s0                        ;
 123  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 124  25000                  RETURN 
 125  1DF02      gs_caseORE: COMPARE sF[Orient], 02[OR_E]       ; case (OR_E):
 126  36133                  JUMP NZ, 133[gs_caseORSE]          ;
 127  11101                  ADD s1, 01                         ;   s4 = gets map(LocX+1, LocY-1)
 128  19201                  SUB s2, 01                         ;
 129  20100                  CALL 100[get_mapvalue]             ;
 12A  00400                  LOAD s4, s0                        ;
 12B  11201                  ADD s2, 01                         ;   s5 = gets map(LocX+1, LocY)
 12C  20100                  CALL 100[get_mapvalue]             ;
 12D  00500                  LOAD s5, s0                        ;
 12E  11201                  ADD s2, 01                         ;   s6 = gets map(LocX+1, LocY+1)
 12F  20100                  CALL 100[get_mapvalue]             ;
 130  00600                  LOAD s6, s0                        ;
 131  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 132  25000                  RETURN 
 133  1DF03     gs_caseORSE: COMPARE sF[Orient], 03[OR_SE]      ; case (OR_SE):
 134  36141                  JUMP NZ, 141[gs_caseORS]           ;
 135  11102                  ADD s1, 02                         ;   s4 = gets map(LocX+2, LocY+1)
 136  11201                  ADD s2, 01                         ;
 137  20100                  CALL 100[get_mapvalue]             ;
 138  00400                  LOAD s4, s0                        ;
 139  19101                  SUB s1, 01                         ;   s5 = gets map(LocX+1, LocY+1)
 13A  20100                  CALL 100[get_mapvalue]             ;
 13B  00500                  LOAD s5, s0                        ;
 13C  11201                  ADD s2, 01                         ;   s6 = gets map(LocX+1, LocY+2)
 13D  20100                  CALL 100[get_mapvalue]             ;
 13E  00600                  LOAD s6, s0                        ;
 13F  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 140  25000                  RETURN 
 141  1DF04      gs_caseORS: COMPARE sF[Orient], 04[OR_S]       ; case (OR_S):
 142  3614F                  JUMP NZ, 14F[gs_caseORSW]          ;
 143  11101                  ADD s1, 01                         ;   s4 = gets map(LocX+1, LocY+1)
 144  11201                  ADD s2, 01                         ;
 145  20100                  CALL 100[get_mapvalue]             ;
 146  00400                  LOAD s4, s0                        ;
 147  19101                  SUB s1, 01                         ;   s5 = gets map(LocX, LocY+1)
 148  20100                  CALL 100[get_mapvalue]             ;
 149  00500                  LOAD s5, s0                        ;
 14A  19101                  SUB s1, 01                         ;   s6 = gets map(LocX-1, LocY+1)
 14B  20100                  CALL 100[get_mapvalue]             ;
 14C  00600                  LOAD s6, s0                        ;
 14D  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 14E  25000                  RETURN 
 14F  1DF05     gs_caseORSW: COMPARE sF[Orient], 05[OR_SW]      ; case (OR_SW):
 150  3615D                  JUMP NZ, 15D[gs_caseORW]           ;
 151  19101                  SUB s1, 01                         ;   s4 = gets map(LocX-1, LocY+2)
 152  11202                  ADD s2, 02                         ;
 153  20100                  CALL 100[get_mapvalue]             ;
 154  00400                  LOAD s4, s0                        ;
 155  19201                  SUB s2, 01                         ;   s5 = gets map(LocX-1, LocY+1)
 156  20100                  CALL 100[get_mapvalue]             ;
 157  00500                  LOAD s5, s0                        ;
 158  19101                  SUB s1, 01                         ;   s6 = gets map(LocX-2, LocY+1)
 159  20100                  CALL 100[get_mapvalue]             ;
 15A  00600                  LOAD s6, s0                        ;
 15B  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 15C  25000                  RETURN 
 15D  1DF06      gs_caseORW: COMPARE sF[Orient], 06[OR_W]       ; case (OR_W):
 15E  3616B                  JUMP NZ, 16B[gs_caseORNW]          ;
 15F  19101                  SUB s1, 01                         ;   s4 = gets map(LocX-1, LocY+1)
 160  11201                  ADD s2, 01                         ;
 161  20100                  CALL 100[get_mapvalue]             ;
 162  00400                  LOAD s4, s0                        ;
 163  19201                  SUB s2, 01                         ;   s5 = gets map(LocX-1, LocY)
 164  20100                  CALL 100[get_mapvalue]             ;
 165  00500                  LOAD s5, s0                        ;
 166  19201                  SUB s2, 01                         ;   s6 = gets map(LocX-1, LocY-1)
 167  20100                  CALL 100[get_mapvalue]             ;
 168  00600                  LOAD s6, s0                        ;
 169  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 16A  25000                  RETURN 
 16B  1DF07     gs_caseORNW: COMPARE sF[Orient], 07[OR_NW]      ; case (OR_NW):
 16C  36179                  JUMP NZ, 179[gs_errcase]           ;
 16D  19102                  SUB s1, 02                         ;   s4 = gets map(LocX-2, LocY-1)
 16E  19201                  SUB s2, 01                         ;
 16F  20100                  CALL 100[get_mapvalue]             ;
 170  00400                  LOAD s4, s0                        ;
 171  11101                  ADD s1, 01                         ;   s5 = gets map(LocX-1, LocY-1)
 172  20100                  CALL 100[get_mapvalue]             ;
 173  00500                  LOAD s5, s0                        ;
 174  19201                  SUB s2, 01                         ;   s6 = gets map(LocX-1, LocY-2)
 175  20100                  CALL 100[get_mapvalue]             ;
 176  00600                  LOAD s6, s0                        ;
 177  2017B                  CALL 17B[set_senvalues]            ;  s0 = new sensor value
 178  25000                  RETURN 
 179  010FF      gs_errcase: LOAD s0, FF                        ; error case - should never get here,
 17A  25000                  RETURN                             ; so return illegal value
 17B                         ; ==============================================================================
 17B                         ; === set_senvalues() - sets sensor values based on the locations around bot ===
 17B                         ; === Registers used:  s4,s5,s6 s7.  Registers affected s0                   ===
 17B                         ; === s4, s5, and s6 contain location type for the left front, center front, ===
 17B                         ; === and right front of the bot.  s7 contains location type for the bot's   ===
 17B                         ; === current location of the bot.  The results are returned in s0           ===
 17B                         ; ==============================================================================
 17B  00070   set_senvalues: LOAD s0, s7                        ; Put the current world location type into bits[7:6]
 17C  14006                  SL0 s0                             ;
 17D  14006                  SL0 s0                             ;
 17E  14006                  SL0 s0                             ;
 17F  14006                  SL0 s0                             ;
 180  14006                  SL0 s0                             ;
 181  14006                  SL0 s0                             ;
 182  05007                  OR s0, 07                          ; assume theres no black line and no obstructions
 183                         ;
 183  1D701                  COMPARE s7, 01[WTYPE_BLKL]         ; if (s7 == Black Line) //crnt loc = black line
 184  36186                  JUMP NZ, 186[setsen_L0]            ; -- Z = 0 says no match
 185  030F8                  AND s0, F8                         ; BlackLine = 000
 186  1D502       setsen_L0: COMPARE s5, 02[WTYPE_OBSTR]        ; if (s5 == OBSTR)   // center front = obstruction
 187  36189                  JUMP NZ, 189[setsen_L1]            ; --Z = 0 says no match
 188  05018                  OR s0, 18                          ; ProxL = ProxR = 1
 189  1D402       setsen_L1: COMPARE s4, 02[WTYPE_OBSTR]        ; if (s4 == OBSTR)  // left front = obstruction
 18A  3618C                  JUMP NZ, 18C[setsen_L2]            ; --Z=0 says no match
 18B  05010                  OR s0, 10                          ; ProxL = 1
 18C  1D602       setsen_L2: COMPARE s6, 02[WTYPE_OBSTR]        ; if (s6 == OBSTR)  // right front = obstruction
 18D  3618F                  JUMP NZ, 18F[setsen_L3]            ; --Z=0 says no macth
 18E  05008                  OR s0, 08                          ; ProxR = 1
 18F  25000       setsen_L3: RETURN 
 190                         ; =============================================================================
 190                         ; === get_botinfo() - returns the value of the BOT info register            ===
 190                         ; === Registers affected: s0, s1                                            ===
 190                         ; === Uses the global registers "Mvmnt" and "Orient"                        ===
 190                         ; === new botinfo register value is returned in s0.                         ===
 190                         ; =============================================================================
 190  000E0     get_botinfo: LOAD s0, sE[Mvmnt]                 ; copy current movement to s0
 191  14006                  SL0 s0                             ; and shift it to bit 4
 192  14006                  SL0 s0                             ;
 193  14006                  SL0 s0                             ;
 194  14006                  SL0 s0                             ;
 195  001F0                  LOAD s1, sF[Orient]                ; copy current orientation to s1
 196  03107                  AND s1, 07                         ; mask out all but lower three bits
 197  04010                  OR s0, s1                          ; and OR with Mvmnt contents
 198  25000                  RETURN 
 199                         ;*******
 199                         ; Functions to implement Rojobot
 199                         ;*******
 199                         ; =====================================================================
 199                         ; === adjthresh() - adjusts paramenters based on BOT configuration  ===
 199                         ; === Registers affected: s0, s1 and VS_ scratch RAM variables      ===
 199                         ; === Assumes BOT configuration is in s0                            ===
 199                         ; =====================================================================
 199  01100       adjthresh: LOAD s1, 00                        ; Assume on/off control
 19A  2F133    adjthr_onoff: STORE s1, 33[VS_ENVSCTL]           ; mode = 00 (on/off control)
 19B  01101                  LOAD s1, 01[MSK_MOTSPD]            ;
 19C  2F132                  STORE s1, 32[VS_MOTCMSK]           ; motor control mask = 01 - only look at low order bit
 19D  01105                  LOAD s1, 05[WTHR_LMOT]             ; left motor threshold = default for on/off
 19E  2F130                  STORE s1, 30[VS_LMTHRSH]           ;
 19F  01105                  LOAD s1, 05[WTHR_RMOT]             ; right motor threshold = default for on/off
 1A0  2F131                  STORE s1, 31[VS_RMTHRSH]           ;
 1A1                         ; Now check mode and adjust parameters if variable speed enabled
 1A1  1400E                  SR0 s0                             ; move mode (on/off or variable speed) to C
 1A2  3D000                  RETURN NC                          ; CF=0 says that mode is on/off so nothing to do
 1A3                         ;
 1A3  01101       adjthr_vs: LOAD s1, 01                        ; otherwise set mode to variable speed
 1A4  2F133                  STORE s1, 33[VS_ENVSCTL]           ;
 1A5  01107                  LOAD s1, 07[MSK_VMOTSPD]           ; motor control mask = 07 - look at all three motor speed bits
 1A6  2F132                  STORE s1, 32[VS_MOTCMSK]           ;
 1A7  00100                  LOAD s1, s0                        ; left and right motor thresholds = bits[4:0]
 1A8  0311F                  AND s1, 1F                         ;
 1A9  2F130                  STORE s1, 30[VS_LMTHRSH]           ; left and right motor thresholds are the same in this version
 1AA  2F131                  STORE s1, 31[VS_RMTHRSH]           ; of the Rojobot configuration register
 1AB  25000                  RETURN 
 1AC                         ; =====================================================================
 1AC                         ; === init_rojobot() - initialize the rojobot                       ===
 1AC                         ; === Registers affected: LMDist, RMDist, Sensor, and Botinf        ===
 1AC                         ; === Assumes Orientation and Movement has already been initialized ===
 1AC                         ; =====================================================================
 1AC  01900    init_rojobot: LOAD s9[LMDist], 00[DISTCTR_IVAL]  ; initialize left and right
 1AD  01800                  LOAD s8[RMDist], 00[DISTCTR_IVAL]  ; motor distance counters
 1AE  01B00                  LOAD sB[Sensor], 00                ; initialize sensors to 0
 1AF  20190                  CALL 190[get_botinfo]              ; initialize BotInfo register
 1B0  00A00                  LOAD sA[Botinf], s0                ;
 1B1  25000                  RETURN 
 1B2                         ; =====================================================================
 1B2                         ; === rojobot() - simulate the rojobot                              ===
 1B2                         ; === Registers affected: LMDist, RMDist, s0, s1, s2, s3            ===
 1B2                         ; === Functions looks at MotCtl and adjusts the distance counters   ===
 1B2                         ; === based on what each of the motors is doing.  Matches motor     ===
 1B2                         ; === speeds by making slower motor move faster.  Returns motor     ===
 1B2                         ; === status (lm_on, rm_on, lm_dir, rm_dir) in s0 for use by the    ===
 1B2                         ; === calc_movement() function.  MotCtl is passed in s0             ===
 1B2                         ; =====================================================================
 1B2  00100         rojobot: LOAD s1, s0                        ; s1[3:0] gets right motor control
 1B3  0310F                  AND s1, 0F[MSK_RMBITS]             ;
 1B4  00200                  LOAD s2, s0                        ; s2[3:0] gets left motor control
 1B5  1420E                  SR0 s2                             ; after you shift it down 4 bits
 1B6  1420E                  SR0 s2                             ;
 1B7  1420E                  SR0 s2                             ;
 1B8  1420E                  SR0 s2                             ;
 1B9                         ; Handle the motor direction bits
 1B9  1410E                  SR0 s1                             ; put rm_dir into carry-bit
 1BA  14008                  SRA s0                             ; and move it to s0[7] to
 1BB                         ; start building motor status
 1BB  1420E                  SR0 s2                             ; put lm_dir into carry-bit
 1BC  14008                  SRA s0                             ; and shift it into place
 1BD  1400E                  SR0 s0                             ; set rm_on and lm_on to "off" by shifting zeros into bits[7:6]
 1BE  1400E                  SR0 s0                             ; the shift also moves lm_dir and rm_dir into bits[5:4]
 1BF                         ;
 1BF                         ; Isolate the speed bits
 1BF  0B332                  FETCH s3, 32[VS_MOTCMSK]           ; Load the speed bit mask
 1C0  02130                  AND s1, s3                         ; mask out right motor speed
 1C1  02230                  AND s2, s3                         ; mask out left motor speed
 1C2                         ;
 1C2  1D100                  COMPARE s1, 00                     ; Is the right motor moving?
 1C3  321C9                  JUMP Z, 1C9[rojobot_01]            ; --ZF is 1 says right motor speed == 0
 1C4  1C120                  COMPARE s1, s2                     ; right motor is moving. Is right motor speed < left motor speed?
 1C5  3E1C7                  JUMP NC, 1C7[rojobot_02]           ; --CF is 0 says right motor speed >= left motor speed
 1C6  00120                  LOAD s1, s2                        ; right motor speed < left motor speed so speed up right motor
 1C7  10810      rojobot_02: ADD s8[RMDist], s1                 ; update right motor distance ctr
 1C8  05040                  OR s0, 40                          ; and set rm_spd to "on" (1)
 1C9                         ; motor status = rm_on, lm_dir, rm_dir xxxxx
 1C9                         ;
 1C9  1D200      rojobot_01: COMPARE s2, 00                     ; Is the left motor moving?
 1CA  321D0                  JUMP Z, 1D0[rojobot_03]            ; --ZF is 1 says left motor speed == 0
 1CB  1C210                  COMPARE s2, s1                     ; left motor is moving.  Is left motor speed < right motor speed?
 1CC  3E1CE                  JUMP NC, 1CE[rojobot_04]           ; -- CF is 0 says left motor speed >- right motor speed
 1CD  00210                  LOAD s2, s1                        ; left motor speed < right motor speed so speed up left motor
 1CE  10920      rojobot_04: ADD s9[LMDist], s2                 ; yst it's moving - update distance ctr
 1CF  05080                  OR s0, 80                          ; and set lm_spd to "on" (1)
 1D0  1400E      rojobot_03: SR0 s0                             ; almost done - move motor status
 1D1  1400E                  SR0 s0                             ; to bits [3:0]
 1D2  1400E                  SR0 s0                             ;
 1D3  1400E                  SR0 s0                             ;
 1D4  25000                  RETURN 
 1D5                         ;**************************************************************************************
 1D5                         ; Software delay routines  (Courtesy Ken Chapman - Xilinx Corp)
 1D5                         ;**************************************************************************************
 1D5                         ; ========================================================
 1D5                         ; === delay_1us() - delays execution for 1 microsecond ===
 1D5                         ; === Registers affected: s0                           ===
 1D5                         ; ========================================================
 1D5  01011       delay_1us: LOAD s0, 11[DELAYVAL_1uS]          ; Load 1us delay constant
 1D6  19001        wait_1us: SUB s0, 01                         ; count down to 0
 1D7  361D6                  JUMP NZ, 1D6[wait_1us]             ; and then return
 1D8  25000                  RETURN 
 1D9                         ; ===========================================================
 1D9                         ; === delay_40us() - delays execution for 40 microseconds ===
 1D9                         ; === Registers affected: s0, s1                          ===
 1D9                         ; ===========================================================
 1D9  01128      delay_40us: LOAD s1, 28                        ; 40 x 1us = 40us
 1DA  201D5       wait_40us: CALL 1D5[delay_1us]                ; delay 1us
 1DB  19101                  SUB s1, 01                         ; count down to 0
 1DC  361DA                  JUMP NZ, 1DA[wait_40us]            ; and then return
 1DD  25000                  RETURN 
 1DE                         ; ========================================================
 1DE                         ; === delay_1 ms() - delays execution for 1 milisecond ===
 1DE                         ; === Registers affected: s0, s1, s2                   ===
 1DE                         ; ========================================================
 1DE  01219       delay_1ms: LOAD s2, 19                        ; 25 x 40us = 1ms
 1DF  201D9        wait_1ms: CALL 1D9[delay_40us]               ; delay 40us
 1E0  19201                  SUB s2, 01                         ; count down to 0
 1E1  361DF                  JUMP NZ, 1DF[wait_1ms]             ; and then return
 1E2  25000                  RETURN 
 1E3                         ; ===================================================================
 1E3                         ; === delay_50 ms() - delays execution for 50 miliseconds (20Hz)===
 1E3                         ; === Registers affected: s0, s1, s2, s3                          ===
 1E3                         ; ===================================================================
 1E3  01332      delay_50ms: LOAD s3, 32                        ; 50 x 1ms = 50ms
 1E4  201DE       wait_50ms: CALL 1DE[delay_1ms]                ; delay 1ms
 1E5  19301                  SUB s3, 01                         ; count down to 0
 1E6  361E4                  JUMP NZ, 1E4[wait_50ms]            ; and then return
 1E7  25000                  RETURN 
 1E8                         ;*********************************************************************
 1E8                         ; ===================================================================
 1E8                         ; === delay_100 ms() - delays execution for 100 miliseconds (10Hz)===
 1E8                         ; === Registers affected: s0, s1, s2, s3                          ===
 1E8                         ; ===================================================================
 1E8  01364     delay_100ms: LOAD s3, 64                        ; 100 x 1ms = 100ms
 1E9  201DE      wait_100ms: CALL 1DE[delay_1ms]                ; delay 1ms
 1EA  19301                  SUB s3, 01                         ; count down to 0
 1EB  361E9                  JUMP NZ, 1E9[wait_100ms]           ; and then return
 1EC  25000                  RETURN 
 1ED                         ;*********************************************************************
 1ED                         ; ==================================================================
 1ED                         ; === delay_200 ms() - delays execution for 200 miliseconds (5Hz)===
 1ED                         ; === Registers affected: s0, s1, s2, s3                         ===
 1ED                         ; ==================================================================
 1ED  013C8     delay_200ms: LOAD s3, C8                        ; 200 x 1ms = 200ms
 1EE  201DE      wait_200ms: CALL 1DE[delay_1ms]                ; delay 1ms
 1EF  19301                  SUB s3, 01                         ; count down to 0
 1F0  361EE                  JUMP NZ, 1EE[wait_200ms]           ; and then return
 1F1  25000                  RETURN 
 1F2                         ;*********************************************************************
 1F2                         ; ===============================================================
 1F2                         ; === delay_1000 ms() - delays execution for 1000 miliseconds ===
 1F2                         ; === Registers affected: s0, s1, s2, s3, s4                  ===
 1F2                         ; ===============================================================
 1F2  01405    delay_1000ms: LOAD s4, 05                        ; 5 x 200ms = 1000ms
 1F3  201ED     wait_1000ms: CALL 1ED[delay_200ms]              ; delay 200ms
 1F4  19401                  SUB s4, 01                         ; count down to 0
 1F5  361F3                  JUMP NZ, 1F3[wait_1000ms]          ; and then return
 1F6  25000                  RETURN 
 1F7                         ;*******************************************************************
 1F7                         ; ****** USE THIS FUNCTION FOR SIMULATION (waits 10 cycles) ******
 1F7                         ; ===========================================================
 1F7                         ; === delay_sim() - delays execution for 10 cycles        ===
 1F7                         ; === Registers affected: s0, s1, s2, s3                  ===
 1F7                         ; ===========================================================
 1F7  0130A       delay_sim: LOAD s3, 0A                        ; delay 10
 1F8  00330        wait_sim: LOAD s3, s3                        ; NOP
 1F9  19301                  SUB s3, 01                         ; count down to 0
 1FA  361F8                  JUMP NZ, 1F8[wait_sim]             ; and then return
 1FB  25000                  RETURN 
 300                         ADDRESS 300
 300                         ;**********************************************************************************************************
 300                         ;**********************************************************************************************************
 300                         ;**********************************************************************************************************
 300                         ;***************          Simple test for the World I/F and Bot logic        ******************************
 300                         ;**********************************************************************************************************
 300  01D00     test_wrldIF: LOAD sD[LocX], 00                  ; initialize LocX and LocY to 0
 301  01C00                  LOAD sC[LocY], 00                  ;
 302  019FF                  LOAD s9[LMDist], FF                ; initialize LMDist and RMDist to FF
 303  018FF                  LOAD s8[RMDist], FF                ;
 304  09000      twrldIF_lp: INPUT s0, 00[PRD_MOTCTL_IN]        ; get motor controls from "system" and save in s0
 305  2D004                  OUTPUT s0, 04[PWR_SENSORS]         ; and write it to world I/F sensor register
 306  11D01                  ADD sD[LocX], 01                   ; increment LocX
 307  00CD0                  LOAD sC[LocY], sD[LocX]            ; LocY =2 * LocX
 308  14C06                  SL0 sC[LocY]                       ;
 309  2DD01                  OUTPUT sD[LocX], 01[PWR_LOCX]      ; and output them to world I/F
 30A  2DC02                  OUTPUT sC[LocY], 02[PWR_LOCY]      ;
 30B  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ; write them to system I/F by pulsing load_sys_regs
 30C  2D00C                  OUTPUT s0, 0C[PRW_LOADREGS]        ;
 30D  201ED                  CALL 1ED[delay_200ms]              ; and sleep for 200 ms
 30E  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; toggle the "system registers updated" flag
 30F  2D00E                  OUTPUT s0, 0E[PRW_UPDSYSREGS]      ; First write togles to 1, second write to 0
 310  22304                  JUMP 304[twrldIF_lp]               ; do this forever


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\rkravitz\Google Drive\_PSUProjects\ece540f17\botip\firmware\bot31_pgm.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   11'd         
 timestamp_minutes 50'd         
 timestamp_seconds 34'd         
 datestamp_year    17'd         
 datestamp_month   8'd          
 datestamp_day     22'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 PRD_MOTCTL_IN     00           bot31_pgm.psm
 PWR_LOCX          01           bot31_pgm.psm
 PWR_LOCY          02           bot31_pgm.psm
 PWR_BOTINFO       03           bot31_pgm.psm
 PWR_SENSORS       04           bot31_pgm.psm
 PWR_RSVD05        05           bot31_pgm.psm
 PWR_RSVD06        06           bot31_pgm.psm
 PRW_RSVD07        07           bot31_pgm.psm
 PWR_COLADR        08           bot31_pgm.psm
 PWR_ROWADR        09           bot31_pgm.psm
 PRD_LOCINFO       0A           bot31_pgm.psm
 PRW_RSVD0B        0B           bot31_pgm.psm
 PRW_LOADREGS      0C           bot31_pgm.psm
 PRW_RSVD0D        0D           bot31_pgm.psm
 PRW_UPDSYSREGS    0E           bot31_pgm.psm
 PRW_RSVD0F        0F           bot31_pgm.psm
 PRD_CONFIG        07           bot31_pgm.psm
 SP_ORTBASE        00           bot31_pgm.psm
 SP_ORTNO          17           bot31_pgm.psm
 SP_ORTNE          20           bot31_pgm.psm
 SP_ORTEA          31           bot31_pgm.psm
 SP_ORTSE          42           bot31_pgm.psm
 SP_ORTSO          53           bot31_pgm.psm
 SP_ORTSW          64           bot31_pgm.psm
 SP_ORTWE          75           bot31_pgm.psm
 SP_ORTNW          06           bot31_pgm.psm
 SP_XYTBASE        10           bot31_pgm.psm
 SP_XYTNO          0F           bot31_pgm.psm
 SP_XYTNE          1F           bot31_pgm.psm
 SP_XYTEA          10           bot31_pgm.psm
 SP_XYTSE          11           bot31_pgm.psm
 SP_XYTSO          01           bot31_pgm.psm
 SP_XYTSW          F1           bot31_pgm.psm
 SP_XYTWE          F0           bot31_pgm.psm
 SP_XYTNW          FF           bot31_pgm.psm
 SP_MVTBASE        20           bot31_pgm.psm
 SP_MVT10          00           bot31_pgm.psm
 SP_MVT32          00           bot31_pgm.psm
 SP_MVT54          CE           bot31_pgm.psm
 SP_MVT76          CE           bot31_pgm.psm
 SP_MVT98          CC           bot31_pgm.psm
 SP_MVTBA          EE           bot31_pgm.psm
 SP_MVTDC          D8           bot31_pgm.psm
 SP_MVTFE          4F           bot31_pgm.psm
 TEMP1             3F           bot31_pgm.psm
 TEMP2             3E           bot31_pgm.psm
 VS_LMTHRSH        30           bot31_pgm.psm
 VS_RMTHRSH        31           bot31_pgm.psm
 VS_MOTCMSK        32           bot31_pgm.psm
 VS_ENVSCTL        33           bot31_pgm.psm
 WSIZE_COLS        80           bot31_pgm.psm
 WSIZE_ROWS        80           bot31_pgm.psm
 WTHR_LMOT         05           bot31_pgm.psm
 WTHR_RMOT         05           bot31_pgm.psm
 WSTRT_COL         40           bot31_pgm.psm
 WSTRT_ROW         40           bot31_pgm.psm
 WTYPE_GND         00           bot31_pgm.psm
 WTYPE_BLKL        01           bot31_pgm.psm
 WTYPE_OBSTR       02           bot31_pgm.psm
 WTYPE_RSVD        03           bot31_pgm.psm
 DISTCTR_IVAL      00           bot31_pgm.psm
 OR_N              00           bot31_pgm.psm
 OR_NE             01           bot31_pgm.psm
 OR_E              02           bot31_pgm.psm
 OR_SE             03           bot31_pgm.psm
 OR_S              04           bot31_pgm.psm
 OR_SW             05           bot31_pgm.psm
 OR_W              06           bot31_pgm.psm
 OR_NW             07           bot31_pgm.psm
 MV_STOP           00           bot31_pgm.psm
 MV_FWD            04           bot31_pgm.psm
 MV_REV            08           bot31_pgm.psm
 MV_SLT            0C           bot31_pgm.psm
 MV_FLT            0D           bot31_pgm.psm
 MV_SRT            0E           bot31_pgm.psm
 MV_FRT            0F           bot31_pgm.psm
 MSK_RMBITS        0F           bot31_pgm.psm
 MSK_LMBITS        F0           bot31_pgm.psm
 MSK_MOTR_STS      0F           bot31_pgm.psm
 MSK_MOTSPD        01           bot31_pgm.psm
 MSK_VMOTSPD       07           bot31_pgm.psm
 DELAYVAL_1uS      17'd         bot31_pgm.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "22 Aug 2017"  
 timestamp$        "11:50:34"     



List of line labels

   Label            Addr  Source PSM File

 * start            000   bot31_pgm.psm
   main             004   bot31_pgm.psm
   emul_lp          00D   bot31_pgm.psm
   emul_lp01        01B   bot31_pgm.psm
   naptime          026   bot31_pgm.psm
   upd_sysregs      028   bot31_pgm.psm
   lkup_nib         037   bot31_pgm.psm
   lkup_nib01       042   bot31_pgm.psm
   lkup_byte        044   bot31_pgm.psm
   init_mvlkuptbl   047   bot31_pgm.psm
   calc_movement    060   bot31_pgm.psm
   init_orlkuptbl   065   bot31_pgm.psm
   next_orient      07E   bot31_pgm.psm
   calc_orient      083   bot31_pgm.psm
 * co_caseSTOP      085   bot31_pgm.psm
   co_caseFWD       089   bot31_pgm.psm
   co_caseREV       08D   bot31_pgm.psm
   co_caseSLT       091   bot31_pgm.psm
   co_caseFLT       097   bot31_pgm.psm
   co_caseSRT       0A0   bot31_pgm.psm
   co_caseFRT       0A6   bot31_pgm.psm
   co_caseDFLT      0AF   bot31_pgm.psm
   co_endcase       0B0   bot31_pgm.psm
   init_xylkuptbl   0B1   bot31_pgm.psm
   next_xy          0CA   bot31_pgm.psm
   get_newxy        0D3   bot31_pgm.psm
   gnxy_01          0DE   bot31_pgm.psm
   gnxy_02          0DF   bot31_pgm.psm
   gnxy_03          0E3   bot31_pgm.psm
   gnxy_00          0E5   bot31_pgm.psm
   gnxy_04          0EB   bot31_pgm.psm
   gnxy_05          0EC   bot31_pgm.psm
   gnxy_06          0F0   bot31_pgm.psm
   gnxy_nofwdrev    0F2   bot31_pgm.psm
   gnxy_chk0B       0F5   bot31_pgm.psm
   gnxy_07          0FD   bot31_pgm.psm
   get_mapvalue     100   bot31_pgm.psm
   get_sensors      105   bot31_pgm.psm
 * gs_caseORN       109   bot31_pgm.psm
   gs_caseORNE      117   bot31_pgm.psm
   gs_caseORE       125   bot31_pgm.psm
   gs_caseORSE      133   bot31_pgm.psm
   gs_caseORS       141   bot31_pgm.psm
   gs_caseORSW      14F   bot31_pgm.psm
   gs_caseORW       15D   bot31_pgm.psm
   gs_caseORNW      16B   bot31_pgm.psm
   gs_errcase       179   bot31_pgm.psm
   set_senvalues    17B   bot31_pgm.psm
   setsen_L0        186   bot31_pgm.psm
   setsen_L1        189   bot31_pgm.psm
   setsen_L2        18C   bot31_pgm.psm
   setsen_L3        18F   bot31_pgm.psm
   get_botinfo      190   bot31_pgm.psm
   adjthresh        199   bot31_pgm.psm
 * adjthr_onoff     19A   bot31_pgm.psm
 * adjthr_vs        1A3   bot31_pgm.psm
   init_rojobot     1AC   bot31_pgm.psm
   rojobot          1B2   bot31_pgm.psm
   rojobot_02       1C7   bot31_pgm.psm
   rojobot_01       1C9   bot31_pgm.psm
   rojobot_04       1CE   bot31_pgm.psm
   rojobot_03       1D0   bot31_pgm.psm
   delay_1us        1D5   bot31_pgm.psm
   wait_1us         1D6   bot31_pgm.psm
   delay_40us       1D9   bot31_pgm.psm
   wait_40us        1DA   bot31_pgm.psm
   delay_1ms        1DE   bot31_pgm.psm
   wait_1ms         1DF   bot31_pgm.psm
   delay_50ms       1E3   bot31_pgm.psm
   wait_50ms        1E4   bot31_pgm.psm
 * delay_100ms      1E8   bot31_pgm.psm
   wait_100ms       1E9   bot31_pgm.psm
   delay_200ms      1ED   bot31_pgm.psm
   wait_200ms       1EE   bot31_pgm.psm
 * delay_1000ms     1F2   bot31_pgm.psm
   wait_1000ms      1F3   bot31_pgm.psm
 * delay_sim        1F7   bot31_pgm.psm
   wait_sim         1F8   bot31_pgm.psm
 * test_wrldIF      300   bot31_pgm.psm
   twrldIF_lp       304   bot31_pgm.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            142
 STAR              -

 AND               9
 OR                7
 XOR               -

 ADD              47
 ADDCY             -
 SUB              28
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          33
 COMPARECY         -

 SL0              12
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0              23
 SR1               -
 SRX               -
 SRA               2
 RR                -

 REGBANK           -

 INPUT             4
 OUTPUT           17
 OUTPUTK           -

 STORE             4
 FETCH             4

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             61
 JUMP@             -
 CALL             66
 CALL@             -
 RETURN           38
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
